public class Extends
{
	public static void main(String[] args)
	{
		//Java的继承通过extends关键字实现, 实现继承的类称为子类, 被继承的类称为父类(基类或超类).父类和子类的关系, 是一种一般和特殊的关系
		//子类是对父类的扩展,子类是一种特殊的父类.子类扩展了父类, 将可以获得父类的全部属性和方法
		//Java的子类不能获得父类的构造器
		//Java中的继承为单继承,即每个类最多只有一个直接父类.
		//如果定义一个类时并未显示指定这个类的直接父类, 则这个类默认扩展java.lang.Object类.因此java.lang.Object是所有类的父类, 要么是其直接父类, 要么是其间接父类.因此所有Java对象都可以调用java.lang.Object类所定义的实例方法
		
		//方法重写(方法覆盖)
		//子类包含与父类同名方法的现象被称为方法重写.可以说子类重写了父类的方法,也可以说子类覆盖了父类的方法.覆盖方法和被覆盖方法要么都是类方法,要么都是实例方法,不能一个是类方法,一个是实例方法
		//方法的重写要遵循"两同两小一大"规则. 
		//"两同"即方法名相同 形参列表相同.
		//"两小"即子类方法返回值类型要比父类方法返回值类型更小或相等, 子类方法声明抛出异常要比父类方法声明抛出异常更小或相等.
		//"一大"即子类方法访问权限要比父类方法访问权限更大或相等.

		//当子类覆盖了父类方法之后, 子类对象将无法访问父类中被覆盖的方法, 但可以在子类方法中调用父类中被覆盖方法.可以使用super(被覆盖的是实例方法)或者父类类名(被覆盖方法是类方法)作为调用者来调用父类中被覆盖方法.
		//如果父类方法具有private访问权限, 则该方法对其子类是隐藏的, 因此其子类无法重写该方法.如果子类中定义了一个与父类private方法具有相同方法名, 相同形参列表, 相同返回值类型的方法, 依然不是重写, 只是在子类中重新定义了一个新方法.

		//如果需要在子类方法中调用父类被覆盖的实例方法, 可使用super作为调用者来调用父类被覆盖的实例方法.
		//子类不会获得父类的构造器, 在一个构造器中调用另一个重载的构造器使用this调用来实现, 在子类构造器中调用父类构造器使用super调用来实现.
		//子类构造器调用父类构造器的几种情况
		//1子类构造器执行体的第一行使用super显示调用父类构造器,

	}
}